import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import {
  faListUl,
  faGrip,
  faUser,
  faCircle,
} from "@fortawesome/free-solid-svg-icons";

export function spacify(identifier) {
  let lastWasUpper = false;
  for (let i = 1; i < identifier.length; i++) {
    if (identifier[i] === identifier[i].toUpperCase()) {
      if (!lastWasUpper) {
        identifier = identifier.substring(0, i) + " " + identifier.substring(i);
        i++;
      }
      lastWasUpper = true;
    } else {
      lastWasUpper = false;
    }
  }
  return identifier;
}

function encodeValue(value) {
  if (Array.isArray(value)) {
    return "()";
  } else if (typeof value === "object" && value.raw !== undefined) {
    return value.raw;
  } else if (typeof value === "string") {
    return JSON.stringify(value);
  } else if (value === false) {
    return "False";
  } else if (value === true) {
    return "True";
  }
  return "";
}

export function renderPinTypeInformation(type) {
  let info = getPinTypeInformation(type);

  let elements = [];
  for (const key of Object.getOwnPropertyNames(info)) {
    elements.push(`${key}=${encodeValue(info[key])}`);
  }
  return elements.join(",");
}

export function getPinTypeInformation(type) {
  if (type.Type === "Simple" || type.Identifier === "FString") {
    switch (type.Identifier) {
      case "bool":
        return {
          "PinType.PinCategory": "bool",
          "PinType.PinSubCategory": "",
          "PinType.PinSubCategoryObject": { raw: "None" },
          "PinType.PinSubCategoryMemberReference": [],
          "PinType.PinValueType": [],
          "PinType.ContainerType": { raw: "None" },
          "PinType.bIsReference": false,
          "PinType.bIsConst": false,
          "PinType.bIsWeakPointer": false,
          "PinType.bIsUObjectWrapper": false,
          "PinType.bSerializeAsSinglePrecisionFloat": false,
          DefaultValue: "0",
          AutogeneratedDefaultValue: "0",
        };
      case "uint8":
        return {
          "PinType.PinCategory": "byte",
          "PinType.PinSubCategory": "",
          "PinType.PinSubCategoryObject": { raw: "None" },
          "PinType.PinSubCategoryMemberReference": [],
          "PinType.PinValueType": [],
          "PinType.ContainerType": { raw: "None" },
          "PinType.bIsReference": false,
          "PinType.bIsConst": false,
          "PinType.bIsWeakPointer": false,
          "PinType.bIsUObjectWrapper": false,
          "PinType.bSerializeAsSinglePrecisionFloat": false,
          DefaultValue: "0",
          AutogeneratedDefaultValue: "0",
        };
      case "int":
      case "int32":
        return {
          "PinType.PinCategory": "int",
          "PinType.PinSubCategory": "",
          "PinType.PinSubCategoryObject": { raw: "None" },
          "PinType.PinSubCategoryMemberReference": [],
          "PinType.PinValueType": [],
          "PinType.ContainerType": { raw: "None" },
          "PinType.bIsReference": false,
          "PinType.bIsConst": false,
          "PinType.bIsWeakPointer": false,
          "PinType.bIsUObjectWrapper": false,
          "PinType.bSerializeAsSinglePrecisionFloat": false,
          DefaultValue: "0",
          AutogeneratedDefaultValue: "0",
        };
      case "int64":
        return {
          "PinType.PinCategory": "int64",
          "PinType.PinSubCategory": "",
          "PinType.PinSubCategoryObject": { raw: "None" },
          "PinType.PinSubCategoryMemberReference": [],
          "PinType.PinValueType": [],
          "PinType.ContainerType": { raw: "None" },
          "PinType.bIsReference": false,
          "PinType.bIsConst": false,
          "PinType.bIsWeakPointer": false,
          "PinType.bIsUObjectWrapper": false,
          "PinType.bSerializeAsSinglePrecisionFloat": false,
          DefaultValue: "0",
          AutogeneratedDefaultValue: "0",
        };
      case "float":
      case "double":
        return {
          "PinType.PinCategory": "float",
          "PinType.PinSubCategory": "",
          "PinType.PinSubCategoryObject": { raw: "None" },
          "PinType.PinSubCategoryMemberReference": [],
          "PinType.PinValueType": [],
          "PinType.ContainerType": { raw: "None" },
          "PinType.bIsReference": false,
          "PinType.bIsConst": false,
          "PinType.bIsWeakPointer": false,
          "PinType.bIsUObjectWrapper": false,
          "PinType.bSerializeAsSinglePrecisionFloat": false,
          DefaultValue: "0",
          AutogeneratedDefaultValue: "0",
        };
      case "FName":
        return {
          "PinType.PinCategory": "name",
          "PinType.PinSubCategory": "",
          "PinType.PinSubCategoryObject": { raw: "None" },
          "PinType.PinSubCategoryMemberReference": [],
          "PinType.PinValueType": [],
          "PinType.ContainerType": { raw: "None" },
          "PinType.bIsReference": false,
          "PinType.bIsConst": false,
          "PinType.bIsWeakPointer": false,
          "PinType.bIsUObjectWrapper": false,
          "PinType.bSerializeAsSinglePrecisionFloat": false,
        };
      case "FString":
        return {
          "PinType.PinCategory": "string",
          "PinType.PinSubCategory": "",
          "PinType.PinSubCategoryObject": { raw: "None" },
          "PinType.PinSubCategoryMemberReference": [],
          "PinType.PinValueType": [],
          "PinType.ContainerType": { raw: "None" },
          "PinType.bIsReference": false,
          "PinType.bIsConst": false,
          "PinType.bIsWeakPointer": false,
          "PinType.bIsUObjectWrapper": false,
          "PinType.bSerializeAsSinglePrecisionFloat": false,
        };
      case "FText":
        return {
          "PinType.PinCategory": "text",
          "PinType.PinSubCategory": "",
          "PinType.PinSubCategoryObject": { raw: "None" },
          "PinType.PinSubCategoryMemberReference": [],
          "PinType.PinValueType": [],
          "PinType.ContainerType": { raw: "None" },
          "PinType.bIsReference": false,
          "PinType.bIsConst": false,
          "PinType.bIsWeakPointer": false,
          "PinType.bIsUObjectWrapper": false,
          "PinType.bSerializeAsSinglePrecisionFloat": false,
        };
      case "FVector":
        return {
          "PinType.PinCategory": "vector",
          "PinType.PinSubCategory": "",
          "PinType.PinSubCategoryObject": { raw: "None" },
          "PinType.PinSubCategoryMemberReference": [],
          "PinType.PinValueType": [],
          "PinType.ContainerType": { raw: "None" },
          "PinType.bIsReference": false,
          "PinType.bIsConst": false,
          "PinType.bIsWeakPointer": false,
          "PinType.bIsUObjectWrapper": false,
          "PinType.bSerializeAsSinglePrecisionFloat": false,
        };
    }
  } else if (type.Type === "Wrapped") {
    let identifier = type.Identifier;

    if (identifier.startsWith("U") && identifier.endsWith("*")) {
      identifier = identifier.substring(1, identifier.length - 1);

      return {
        "PinType.PinCategory": "object",
        "PinType.PinSubCategory": "",
        "PinType.PinSubCategoryObject": {
          raw: `Class'"/Script/OnlineSubsystemBlueprints.${identifier}"'`,
        },
        "PinType.PinSubCategoryMemberReference": [],
        "PinType.PinValueType": [],
        "PinType.ContainerType": { raw: "None" },
        "PinType.bIsReference": false,
        "PinType.bIsConst": false,
        "PinType.bIsWeakPointer": false,
        "PinType.bIsUObjectWrapper": false,
        "PinType.bSerializeAsSinglePrecisionFloat": false,
      };
    }

    if (
      identifier.startsWith("E") &&
      identifier.substring(1, 1) === identifier.substring(1, 1).toUpperCase()
    ) {
      identifier = identifier.substring(1);

      return {
        "PinType.PinCategory": "byte",
        "PinType.PinSubCategory": "",
        "PinType.PinSubCategoryObject": {
          raw: `Enum'"/Script/OnlineSubsystemBlueprints.E${identifier}"'`,
        },
        "PinType.PinSubCategoryMemberReference": [],
        "PinType.PinValueType": [],
        "PinType.ContainerType": { raw: "None" },
        "PinType.bIsReference": false,
        "PinType.bIsConst": false,
        "PinType.bIsWeakPointer": false,
        "PinType.bIsUObjectWrapper": false,
        "PinType.bSerializeAsSinglePrecisionFloat": false,
      };
    }

    if (
      identifier.startsWith("F") &&
      identifier.substring(1, 1) === identifier.substring(1, 1).toUpperCase()
    ) {
      identifier = identifier.substring(1);

      let scriptStruct = `/Script/OnlineSubsystemBlueprints.${identifier}`;
      if (identifier === "UniqueNetIdRepl") {
        scriptStruct = `/Script/Engine.${identifier}`;
      }

      return {
        "PinType.PinCategory": "struct",
        "PinType.PinSubCategory": "",
        "PinType.PinSubCategoryObject": {
          raw: `ScriptStruct'"${scriptStruct}"'`,
        },
        "PinType.PinSubCategoryMemberReference": [],
        "PinType.PinValueType": [],
        "PinType.ContainerType": { raw: "None" },
        "PinType.bIsReference": false,
        "PinType.bIsConst": false,
        "PinType.bIsWeakPointer": false,
        "PinType.bIsUObjectWrapper": false,
        "PinType.bSerializeAsSinglePrecisionFloat": false,
      };
    }
  }

  // Unknown
  return {
    "PinType.PinCategory": "struct",
    "PinType.PinSubCategory": "",
    "PinType.PinSubCategoryObject": {
      raw: "ScriptStruct'\"/Script/Engine.UniqueNetIdRepl\"'",
    },
    "PinType.PinSubCategoryMemberReference": [],
    "PinType.PinValueType": [],
    "PinType.ContainerType": { raw: "None" },
    "PinType.bIsReference": false,
    "PinType.bIsConst": false,
    "PinType.bIsWeakPointer": false,
    "PinType.bIsUObjectWrapper": false,
    "PinType.bSerializeAsSinglePrecisionFloat": false,
  };
}

function getResolveTypeRender(type) {
  if (type.Type === "Map") {
    let val = getResolveTypeRender(type.Value);
    return {
      icon: faListUl,
      color: val.color,
      identifier: val.identifier,
    };
  } else if (type.Type === "Array") {
    let val = getResolveTypeRender(type.Element);
    return {
      icon: faGrip,
      color: val.color,
      identifier: val.identifier,
    };
  } else if (type.Type === "Simple" || type.Identifier === "FString") {
    switch (type.Identifier) {
      case "bool":
        return {
          icon: faCircle,
          color: "#950000",
          identifier: "Boolean",
        };
      case "uint8":
        return {
          icon: faCircle,
          color: "#006F65",
          identifier: "Byte",
        };
      case "int":
      case "int32":
        return {
          icon: faCircle,
          color: "#1FE3AF",
          identifier: "Integer",
        };
      case "int64":
        return {
          icon: faCircle,
          color: "#ACE3AF",
          identifier: "Integer64",
        };
      case "float":
      case "double":
        return {
          icon: faCircle,
          color: "#38D500",
          identifier: "Float",
        };
      case "FName":
        return {
          icon: faCircle,
          color: "#CD82FF",
          identifier: "Name",
        };
      case "FString":
        return {
          icon: faCircle,
          color: "#FF00D4",
          identifier: "String",
        };
      case "FText":
        return {
          icon: faCircle,
          color: "#E77CAA",
          identifier: "Text",
        };
      case "FVector":
        return {
          icon: faCircle,
          color: "#FFCA23",
          identifier: "Vector",
        };
    }
  } else if (type.Type === "Wrapped") {
    let icon = faCircle;
    if (type.Identifier === "FUniqueNetIdRepl") {
      icon = faUser;
    }

    let isEnum = false;
    let identifier = type.Identifier;
    if (identifier.startsWith("U") && identifier.endsWith("*")) {
      identifier = identifier.substring(1, identifier.length - 1);
    }
    if (identifier.endsWith("&") || identifier.endsWith("_")) {
      identifier = identifier.substring(0, identifier.length - 1);
    }
    if (
      (identifier.startsWith("F") || identifier.startsWith("E")) &&
      identifier.substring(1, 1) === identifier.substring(1, 1).toUpperCase()
    ) {
      isEnum = identifier.startsWith("E");
      identifier = identifier.substring(1);
    }
    identifier = spacify(identifier);

    return {
      icon,
      color: isEnum ? "#006F65" : "#0059CB",
      identifier,
    };
  }

  return {
    icon: faCircle,
    color: "#333",
    identifier: JSON.stringify(type),
  };
}

export default function TypeRenderer(props: { typeInfo: any }) {
  let typeRender = getResolveTypeRender(props.typeInfo);
  return (
    <span>
      <FontAwesomeIcon
        icon={typeRender.icon}
        className=""
        fixedWidth
        style={{ color: typeRender.color }}
      />{" "}
      {typeRender.identifier}
    </span>
  );
}
